# -*- coding: utf-8 -*-
"""264.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aRRx17gOAvJSOj12GAtuLv7Df4yLY6wP
"""

class Beam:
  def __init__(self,load,length,E,I):
    self.load=load
    self.length=length
    self.E=E
    self.I=I
  def deflection(self):
    return(self.load*self.length**3)/(48*self.E*self.I)
beam1=Beam(1000,2,2e11,8e-6)
print("deflection:",round(beam1.deflection(),6),"m")

fruits=["apple","banana","cherry"]
fruits.append("orange")
print("fruits:",fruits)
dimension=(2,4,6)
print(dimension[1])

import numpy as np
import matplotlib.pyplot as plt

    # In a real system, you'd have a motor model here
    motor_speed = motor_speed + output * dt# Simulation parameters
setpoint = 100  # Desired motor speed (RPM)
Kp = 0.1      # Proportional gain
Ki = 0.01     # Integral gain
Kd = 0.05     # Derivative gain
dt = 0.1      # Time step for simulation (seconds)
sim_time = 150 # Total simulation time (seconds)

# Controller initialization
integral = 0
previous_error = 0
motor_speed = 0  # Initial motor speed (RPM)

# Store data for plotting
time_data = []
speed_data = []

# Simulation loop
for t in np.arange(0, sim_time, dt):
    # Calculate error
    error = setpoint - motor_speed

    # PID calculations
    integral = integral + error * dt
    derivative = (error - previous_error) / dt
    output = Kp * error + Ki * integral + Kd * derivative

    # Update motor speed (simplified model)


    # Store data for plotting
    time_data.append(t)
    speed_data.append(motor_speed)

    # Update previous error
    previous_error = error

# Plot the results
plt.plot(time_data, speed_data)
plt.xlabel("Time (s)")
plt.ylabel("Motor Speed (RPM)")
plt.title("DC Motor Speed Control with PID")
plt.grid(True)
plt.show()